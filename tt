vector< string > pol1,pol2;
struct point
{
    double x,y;
    point(double a=0,double b=0)
    {
        x=a; y=b;
    }
    bool operator<(const point &p)const
    {
        if(dcmp(x,p.x)!=0)
            return dcmp(x,p.x)<0;
        return dcmp(y,p.y)<0;
    }
    point operator*(const double &e)const
    {
        return point(x*e,y*e);
    }
    point operator-(const point &p)const
    {
        return point(x-p.x,y-p.y);
    }
    double absl()const
    {
        return sqrt(x*x+y*y);
    }
    double dist(const point &p)const
    {
        return sqrt((x-p.x)*(x-p.x)+(y-p.y)*(y-p.y));
    }
    point operator+(const point &p)const
    {
        return point(x+p.x,y+p.y);
    }
};
double cross(point a,point b)
{
    return a.x*b.y-a.y*b.x;
}

point curp;
struct seg
{
    point s,e;
    int id;
    seg(point a=point(0,0),point b=point(0,0),int c=0)
    {
        if(b<a)
            swap(a,b);
        s=a; e=b;
        id=c;
    }

};
int x;
struct CMP
{
    double interpolate(const  point &a,const point &b,int &x)
    {
        if(dcmp(a.x,b.x)==0)
            return a.y;

        return a.y+ ((b.y-a.y)/(b.x-a.x))*(x-a.x);
    }
    bool operator() (const seg &a,const seg &b )
    {
        return dcmp(interpolate(a.s,a.e,x),interpolate(b.s,b.e,x))<0;
    }
};
struct event
{
    point p;
    int st,id;
    event(point a,int b,int c)
    {
        p=a; st=b; id=c;
    }
    bool operator<(const event &e)const
    {
        if(dcmp(p.x,e.p.x)!=0)
            return dcmp(p.x,e.p.x)<0;
        if(st!=e.st)
            return st<e.st;
        return dcmp(p.y,e.p.y)<0;
    }
};
vector< point > p1,p2,A;
vector< seg > sg;
vector< event > e;
set< seg,CMP > S;
typedef set<seg>::iterator ITER;
map< point ,int > mb;


void getintersect(point a,point b,point c,point d)
{
    double d1= cross((a-b),(d-c)), d2=cross((a-c),(d-c)), d3=cross((a-b),(a-c));

    if(fabs(d1)<eps)
        return;
    double t1=d2/d1,t2=d3/d1;
    point inter= a+(b-a)*t1;

    if(t1<-eps||t1>1+eps||t2<-eps||t2>1+eps)
        return ;
    if(mb.find(inter)==mb.end())
    {
      A.pb(inter);
      mb[inter]=1;
    }
}

void intersect(seg a,seg b)
{
    int id1=a.id, id2=b.id;
    getintersect(sg[id1].s,sg[id1].e,sg[id2].s,sg[id2].e);
}






void linsweepintersection()
{

    for(int i=0;i<sz(sg);i++)
    {
        e.pb(event(sg[i].s,1,i));
        e.pb(event(sg[i].e,2,i));
    }

    sort(all(e));

    for(int i=0;i<sz(e);i++)
    {

       x=e[i].p.x;
       
      if(e[i].st==1)
      {

      auto above=S.upper_bound(sg[e[i].id]);
      auto below=S.lower_bound(sg[e[i].id]);

      if(above!=S.end())
      intersect(sg[e[i].id],*(above));
      if(below!=S.begin())
      {
          below--;
          intersect(sg[e[i].id],*(below));
      }
      }
      else
      {
         auto above=S.upper_bound(sg[e[i].id]);
         auto below=S.lower_bound(sg[e[i].id]);


      if(below!=S.begin()&&above!=S.end())
      {
          below--;
          intersect(*(below),*(above));
      }

      }

     if(e[i].st==1)
        S.insert(sg[e[i].id]);
     else
     {
         auto it=S.find(sg[e[i].id]);
         if(it!=S.end())
            S.erase(it);
     }
    }

}









class ConvexPolygons
{
public:

    double overlap(vector <string> polygon1, vector <string> polygon2)
    {
        int x,y;
        for(int i=0;i<sz(polygon1);i++)
        {
            stringstream ss(polygon1[i]);
            ss>>x>>y;
            //cout<<x<<" "<<y<<endl;
            p1.pb(point(x,y));
            mb[point(x,y)]=1;
        }
       // cout<<endl;
        for(int i=0;i<sz(polygon2);i++)
        {
            stringstream ss(polygon2[i]);
            ss>>x>>y;
           // cout<<x<<" "<<y<<endl;
            p2.pb(point(x,y));
            mb[point(x,y)]=1;
        }

        p1.pb(p1[0]);
        p2.pb(p2[0]);

        for(int i=0;i<sz(p1)-1;i++)
        {
            sg.pb(seg(p1[i],p1[i+1],sz(sg)));
        }
        for(int i=0;i<sz(p2)-1;i++)
        {
            sg.pb(seg(p2[i],p2[i+1],sz(sg)));
        }
        //cout<<sz(sg)<<endl;

        linsweepintersection();


    }
};

/*
int main()
{
    pol1.pb("00 00");pol1.pb("02 00"); pol1.pb("00 03");
    pol2.pb("1 1");pol2.pb("3 1");pol2.pb("3 3");pol2.pb("1 3");
    ConvexPolygons e;
    e.overlap(pol1,pol2);
    for(int i=0;i<sz(A);i++)
        cout<<A[i].x<<" "<<A[i].y<<endl;
}
*/


