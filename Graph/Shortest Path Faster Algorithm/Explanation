/*
(SPFA) Shortest Path Faster Algorithm:it is a single source shortest path, it is idea comes from BellmanFord's idea where
i won't need to move more than n-1 edges because the maximum length of the shortest path is n-1 because it will be a 
simple path for sure, it is like i am moving level wise from the source level by level and there is no node as higher 
level will reduce the value of a node at lower level except if there is a negative cycle and i will detect that later so
the max levels needed to checked is n-1.

Complexity: for N nodes,M edges worest case (N*M) but in average (happens most of the time) O(M).
*/
CODE
----
#include <bits/stdc++.h>
using namespace std;
typedef pair<int,int> ii;
queue<int> q;
const int N=10003;  // put number of nodes+3 here PLS CHANGE THIS ACCORDINGLY
int w[N],c2[N];   //w is shortest path to a node, c2 is number of time a node has been relaxed
bool c[N];   //c is to check whether a certain node is in the queue
vector<ii> data [N]; //adjacency list of graph
void edge(int x,int y, int l)
{  //there is a directed edge from x to y with length l
    data[x].push_back(ii (y,l));
}
void initialize()
{   
    //initialize variables, may not be the fastest
    memset(c2,0,sizeof(c2));  
    memset(c,true,sizeof(c));
    memset(w,63,sizeof(w));   //depends on largest path from 1 node to another IMPORTANT
    for (int x=0;x<N;x++)
    {
        data[x].clear();
    }
    //note that the algorithm until the queue is empty so there is no need to initialize queue
}
void bfs(int x)
{   
    //this is no mark everything under the negative weight cycle as inf length
    int l=data[x].size(),a;
    for (int y=0;y<l;y++)
    {   
        //for each of x neighbour
        a=data[x][y].first;
        if (c2[a]<N)
        {   
            // if neighbour is not marked as -INF length
            c2[a]=N; //mark it as such
            bfs(a); //mark all its neighbours as such
        }
    }
}
void SPFA(int s)
{
    //s is the source node
    q.push(s);
    w[s]=0;
    int n,l,u,d;
    
   while (!q.empty())
   {
    n=q.front(); // n is node to relax neighbours
    q.pop();
    if (c2[n]>=N) continue; // if n is part of negative weight cycle, ignore
    
    c[n]=true; //mark n is not in queue
    l=data[n].size(); //just for constant time improvement
    
    for (int x=0;x<l;x++)
    {
        u=data[n][x].first;
        d=data[n][x].second;
        if (w[u]>w[n]+d)
        {  
            // if u can be relaxed
            w[u]=w[n]+d; //relaxing u
            c2[u]++;// count number of time u has been relaxed. as u can only be relaxed N-1 times if its not in negative weight cycle
            if (c2[u]==N)
            {   //if n in is negative wieght cycle
                bfs(u); //mark all of u neighbours as - INF weight
            }
            else if (c[u])
            {   //if u is not in queue
                c[u]=false; //mark u is in queue
                q.push(u); //push u into queue
            }
        }
    }
  }
}
void print(int n)
{   // print length of shortest path
    if (c2[n]>=N)
    {
        printf("-Infinity\n"); //part of negative wieght cycle
    }
    else if (w[n]==1061109567)
    {
        printf("Impossible\n"); //unreachable form source node
    }
    else
    {
        printf("%d\n",w[n]); //else just print its shortest path
    }
}
int main()
{   // the example graph has 5 nodes and 4 edges
    initialize();  //pls initialize or weird stuff might happen
    edge(0,1,999);
    edge (1,2,-2);
    edge(2,1,1);
    edge (0,3,2);
    SPFA(0); //0 is source node
    print(1);
    print(3);
    print(4);
    return 0;
}
----------------------------------------------------------------------------------------------------------------------------------------
