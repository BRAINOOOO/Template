Segment tree + Lazy Propagation
// Size of tree array  is 2^(t+1) - 1 , t=log(n)/log(2)
//#define mid ((st + en) >> 1)
//Sum segment tree
----------------------------------------------------------------------------------------------------------------------------------------
idea of lazy

- lazy is like a flag i use it to know the value of the smaller sub ranges in the big range when i need that smaller range
----------------------------------------------------------------------------------------------------------------------------------------


inline void build(int st = 0, int en = n - 1, int root = 1)
{
if(st == en)
{
  tree[root] = arr[st];
   return;
}

build(st, mid, root << 1);
build(mid + 1, en, (root << 1)|1);

tree[root] = tree[root << 1] + tree[(root << 1) |1];
}
//Update by idx and changes value (not addition)




void update(int idx, int val, int st, int en, int root)
{
  if(idx < st || idx > en)
   return;
  if(st == en)
  {
    tree[root] = val;
    return;
   }
update(idx, val, st, mid, root << 1);
update(idx, val, mid + 1, en, (root << 1) | 1);
tree[root] = tree[root << 1] + tree[(root << 1) |1];
}




//Query on range (Not LAZY)

int query(int L, int R, int st, int en, int root)
{
  if(L > en || R < st)
   return 0;
   if(st >= L && en <= R)
   return tree[root];
   return query(L, R, st, mid, root << 1) + query(L,R, mid + 1, en, (root << 1) | 1);
}




//Lazy Propagation----------------------------------------------------------------------------------------

inline void build(int st = 0, int en = n - 1, int root = 1)
{
if(st == en)
{
  tree[root] = st + 1;
   return;
}
int mid = (st + en) >> 1;
build(st, mid, root << 1);
build(mid + 1, en, (root << 1)|1);
}

---------------------------------------------------------------------
// general lazy

inline void apply(int root)
{
  if(lazy[root] == -1)
   return;
    int L = root << 1;
    int R = (root << 1) | 1;
    lazy[L] = lazy[R] = tree[L] = tree[R] = lazy[root];
    lazy[root] = -1;
}

------------------------------------------------------------------
//Query By idx

inline int query(int idx, int st, int en, int root)
{
    if(idx < st || idx > en)
      return 0;
    if(st == en)
     return tree[root];
     apply(root);
      return query(idx , st, mid, root << 1) + query(idx, mid + 1, en, (root << 1) | 1);
}
//   query with lazy
-------------------------------------------------------------------------------------

inline void update(int val, int L, int R, int st,int en, int root)
{
  if(R < st || L > en)
   return;

if(st >= L && en <= R)
{
  tree[root] = val;
  lazy[root] = val;
  return;
}
apply(root);
update(val, L, R, st, mid, root << 1);
update(val, L, R, mid + 1, en, (root << 1) | 1);
}
// update with lazy
-------------------------------------------------------------------------------------------------
//Lazy Sum

void apply(int root, int st, int mid , int en)
{
   int r = root * 2 + 1;
   int l = root * 2;
lazy[r] += lazy[root];
lazy[l] += lazy[root];
tree[r] += lazy[root] * (en - (mid + 1) + 1);
tree[l] += lazy[root] * (mid - st + 1);
lazy[root] = 0;
}
----------------------------------------------------------------------------------------------------
//  update with lazy RSQ

void update(int L, int R, int val, int st = 0, int en = n - 1, int root = 1){
if(L > en || R < st)
return;
if(st >= L && en <= R)
{
tree[root] += 1LL * val * (en - st + 1);
lazy[root] += val;    // Children are to beupdated
return;
}

int mid = (st + en) >> 1; //Query not in the current range
apply(root, st, mid, en);
update(L, R, val, st, mid, root * 2);
update(L, R, val, mid + 1, en, root * 2 + 1);
tree[root] = tree[root * 2] + tree[root * 2 + 1];
}

--------------------------------------------------------------------------------------------------------

// query with lazy RSQ

ll query(int L, int R, int st = 0, int en = n - 1,int root = 1)
{
if(L > en || R < st)
return 0;

if(st >= L && en <= R)
return tree[root];

int mid = (st + en) >> 1;
apply(root, st, mid, en);
return query(L, R, st, mid, root * 2) + query(L,R, mid + 1, en, root * 2 + 1);

}

----------------------------------------------------------------------------------------------------------------
The above query may TL , here is more optimal code for query 

int query(int a,int b,int s=1,int e=n,int root=1)
{

    if(a<=s&&e<=b)
    {
        return tree1[root];
    }
    int mid=(s+e)>>1;
    if(b<=mid)
      return query1(a,b,s,mid,root*2);
   else if(a>mid)
      return  query1(a,b,mid+1,e,root*2+1);


   return max(query1(a,b,s,mid,root*2),query1(a,b,mid+1,e,root*2+1));
}

----------------------------------------------------------------------------------------------------------------------------------------
IF you have ranges and you want to ( query on the all the tree (only) ) how many elements in this range but every cell have to 
contain at most one element and the update is on the range whether be +1 or -1 .

CODE
----
#define L(n)((n)<<(1))
#define R(n)(L(n)+(1))

struct node {
   int cnt, lzy;
   node() : cnt( 0 ), lzy( 0 ) {}
};
void Construct( int n ) {
   for( tlen = 1; tlen < n; tlen <<= 1 );
   Tree.resize( tlen << 1 );
}
vector< node > Tree;
int lo, hi, tlen;
void update( int x, int y, int v, int n ) {
   if( x >= hi || y <= lo ) return;
   if( x >= lo && y <= hi ) {
      Tree[ n ].lzy += v;
      if( Tree[ n ].lzy ) Tree[ n ].cnt = ( y - x );
      if( Tree[ n ].lzy < 1 ) {
         if( n >= tlen ) Tree[ n ].cnt = 0;
         else Tree[ n ].cnt = Tree[ L( n ) ].cnt + Tree[ R( n ) ].cnt;
      }
      return;
   }

   update( x, ( x + y )>>1, v, L( n ) );
   update( ( x + y )>>1, y, v, R( n ) );

   if( Tree[ n ].lzy < 1 )
      Tree[ n ].cnt = Tree[ L( n ) ].cnt + Tree[ R( n ) ].cnt;
}

void Update( int x, int y, int v ) {
   lo = x; hi = y;
   update( 0, tlen, v, 1 );
}
int query( int x, int y, int n ) {
   if( x >= hi || y <= lo ) return 0;
   if( x >= lo && y <= hi ) return Tree[ n ].cnt;
   if( Tree[ n ].lzy ) return min( y, hi ) - max( x, lo );

   return query( x, ( x + y )>>1, L( n ) ) +
          query( ( x + y )>>1, y, R( n ) );
}
int Query() {
   lo = 0; hi = 30005;
   return query( 0, tlen, 1 );
}

int main()
{
    Construct( 30005 );
     Query();
     Update( From, to, value );
}
----------------------------------------------------------------------------------------------------------------------------------------

























